import socket
import struct
import psutil
import subprocess

class colors:
      red = "\033[31m"
      green = "\033[32m"
      blue = "\033[34m"
      cyan = "\033[36m"
      purple = "\033[35m"
      reset = "\033[0m"
      pink = "\033[95m"

      # FORMAT TEXT
      bright = '\033[1m'
      background_green = '\033[32m'
      background_red = '\033[41m'
      blink = '\033[5m'
      sublime = '\033[4m'

      # COLOR + BRIGHT
      sb = f'{bright}{sublime}'
      gb = f'{bright}{green}'
      bb = f'{bright}{blue}'

def show_interfaces_addrs():
    try:
       print()
       address_interfaces = psutil.net_if_addrs()
       for interfaces in address_interfaces:
           for info in address_interfaces.get(interfaces):
               if psutil.AF_LINK in info:
                  print(f"{colors.green}{info.address} => {colors.gb}{interfaces}{colors.reset}")
       print()
    except Exception as error:
           print(f"Error to get interfaces and address );\n{colors.red}{str(error)}{colors.reset}\n")

def set_interface_mode(iface_options):
    if iface_options == 0:
       print()
       interface_to_monitor = input(f"{colors.bright}Type it interface for set monitor mode: {colors.reset}")
       try:
          subprocess.run(['ip', 'link', 'set', interface_to_monitor, 'down'])
          subprocess.run(['iw', 'dev', interface_to_monitor, 'set', 'type', 'monitor'])
          subprocess.run(['ip', 'link', 'set', interface_to_monitor, 'up'])
       except Exception as error:
              print(f"Error to the set {interface_to_monitor} for monitor mode ); {str(error)}")

    elif iface_options == 1:
         print()
         add_interface_monitor = input("{colors.bright}Type it the interface wireless, for create a other interface virtual in monitor mode: {colors.reset}")
         print()
         try:
            subprocess.run(['iw', 'dev', add_interface_monitor, 'interface', 'add', 'wlan0monitor', 'type', 'monitor'])
            subprocess.run(['ip', 'link', 'set', 'wlan0monitor', 'up'])
         except Exception as error:
                print(f"Error to the create virtual interface in monitor mode ); {colors.red}{str(error)}{colors.reset}")
    else:
        print(f"Type it {colors.red}0{colors.reset} or {colors.green}1{colors.reset}")
    print()
    show_interfaces_addrs()

def return_addresses(interface_network):
    addresses_interface = psutil.net_if_addrs()
    if interface_network in addresses_interface:
       for info in addresses_interface.get(interface_network):
           for address in info:
               if psutil.AF_LINK in info:
                  return info.address
    return None

def mac_for_bytes(mac):
    return bytes(int(byte, 16) for byte in mac.split(':'))

def bytes_for_mac(mac):
    return ':'.join(format(byte, '02X') for byte in mac)

def calc_rates(rates):
    list_rates_transmition = []
    for rate in rates:
        # OPERATION: AND BIT BY BIT, (rate binary & value hexadecimal: 0x7f/01111111) * 500 
        value_rate = (rate & 0x7f) * 500
        list_rates_transmition.append(f"{value_rate} Mbps")
    return list_rates_transmition

def idenfify_interface_mode(interface):
    try:
       infomations_iface = subrpocess.run(['iwconfig', interface], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=False)
       if "Mode:monitor" in informations_iface.stdout.decode('utf-8'):
          print
    except Exception as error:
           print(f"Error ): it was not possible identify interface mode... {colors.red}{str(error)}, stderr: {information_iface.stderr}{colors.reset}")
           
# AGROUP ALL PACKETS INFO IN A CLASS packets_info
class InfoPackets:                                      # LENGTH PACKET
      radiotap_header = struct.pack('<HHH', 0x00, 0x00, 0x0c)
      mac_interface = return_addresses(interface)
      mac_interface_byte = mac_for_bytes(mac_interface)
      broadcast_addr = b'\xff\xff\xff\xff\xff\xff'
      bssid = b'\xff\xff\xff\xff\xff\xff'
      # THE FRAME CONTROL DATA GOES TO THE DESTINATION ADDRESS FIELD AND WILL ALSO WORK OR DESTINY ADDRESS FIELD COULD IT BE EMPTY
      # THAT ALL THE APS(ACCESS POINTS) WILL UNDERSTAND YOU WANT TO GET NETWORK SSIDs NEARBY   
      header_iee802 = struct.pack('<6s6s', b'', broadcast_addr)
      supported_rates = [0x82, 0x84, 0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c]
      bytes_rates = bytes(supported_rates)
      rates = struct.pack('<BB', 0x01, 0x08) + bytes_rates
      list_rates_transmission = calc_rates(supported_rates)
      ssid_field = struct.pack('<BB', 0x00, 0x00) + b''
      payload_test = struct.pack('<BBBB', 0x01, 0x02, 0x03, 0x04)

# USING STRUCT FOR UNPACK PACKETS AND YOUR DATA, IN CORRECT FORMAT!
# IT IS NECESSARY TO KNOW WHAT TYPES OF DATA ARE COMING, THEIR ORDER AND POSITION, THEREFORE WE NEED COMMUNICATIONS PROTOCOLS WITH 
# STANDARDS FOR SENDING THE DATA IN ORDER, SO THAT OTHER LOW LEVEL PORGRAMS LIKE THIS ARE ABLE TO PREDICT AND PROPERLY DEAL WITH THE 
# DATA EXPECTED
# HEADER ACCORDINGLY WITH TYPE PACKET

# TYPES PACKET: 0X00/00000000 Association Request, 0x01/00000001 Association Reponse, 0x04/00000100 Probe Request, 0x05/00001001 
# Probe Response,
# 0x0a/00001010 Disassociation, 0x0b/00001011 Authentication, 0x0c/00001100 Deauthentication
# DECODE SHOW PACKETS:

def decode_packets(packet, address):
    packet_data = {}
    mac_src = bytes_for_mac(address[4])
    packet_data["PACKET ORIGIN"] = mac_src
    return packet_data
    
def SendPackets(interface_network):
    packet_deauthentication_probe = InfoPackets.header_iee802 + InfoPackets.ssid_field + InfoPackets.rates
    try:
       print(f"\n{colors.bright}INTERFACE IN OPERATION:{colors.reset} {colors.gb}{interface_network} => {InfoPackets.mac_interface} OR {InfoPackets.mac_interface_byte}{colors.reset}")
       print(f"\n{colors.bright}SUPPORTED RATES(DEFAULT): {InfoPackets.list_rates_transmission} OR {InfoPackets.bytes_rates}{colors.reset}")
       print(f"\n{colors.gb}PACKAGE SENT =>{colors.reset} {colors.red}{packet_deauthentication_probe}{colors.reset}\n")

       with socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003)) as sock:
           sock.bind((interface_network, 0))
           sock.send(packet_deauthentication_probe)
           while True:
                 packet, address = sock.recvfrom(2000)
                 print(decode_packets(packet, address))
    except Exception as error:
           print(f"A Error occur ); {colors.red}{str(error)}{colors.reset}\n")
           sock.close()

if __name__ == "__main__":
   show_interfaces_addrs()
   config_interfaces = int(input(f"{colors.bright}You want set interface? for monitor mode: {colors.reset}"))
   try:
      if config_interfaces == 1:
         show_interfaces_addrs()
         print(f"{colors.green}Type it: {colors.gb}1{colors.reset} {colors.green}to set a interface for monitor mode. {colors.purple}Type it: {colors.gb}0{colors.reset} {colors.purple}for add interface virtual in monitor mode:{colors.reset}\n")
         interface_monitor_option = int(input(f"{colors.green}You want: Set interface for monitor mode or add virtual interface in monitor mode? {colors.gb}1{colors.reset}/{colors.gb}0{colors.reset}: "))
         set_monitor(interface_monitor_option)
   except Exception as error:
          print(f"Error to the set config ): or just option 0 (: {colors.red}{str(error)}{colors.reset}\n")

   interface = input(f"{colors.bright}Type it MANAGED interface Network for operation: {colors.reset}")
   SendPackets(interface)
