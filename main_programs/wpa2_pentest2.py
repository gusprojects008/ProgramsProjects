# FIRST, SEND BEACON/FLAGS PACKETS, SO NEARBY ROUTERS UNDERSTAND THAT YOU WANT TO DISCOVER NEARBY WIFI NETWORKS.

# UNDERSTAND THE BASIC PACKAGE STRUCTURE: address headers: (Mac Source => Mac Destination), (Protocol), (package number), (Flags),
# (Checksum for validating the packets),
# TTL(Time to Live), (port source => port destination). (Payload Data).

# THIS IS AN EXAMPLE OF A BASIC NETWORK PACKAGE, AND DEPENDING ON THE TYPE OF PACKAGE, OTHER INFORMATION WILL BE REQUIRED
# BUT AS WE ARE CREATING A BEACON PACKAGE WE NEED TO PASS AND WAIT FOR INFORMATION LIKE RESPONSE PACKETS SSID AND OTHER INFORMATION.

# PACKAGE HEADERS ARE NECESSARY TO MAINTAIN THE ORDER AND ORGANIZATION OF DATA EXCHANGE AND COMMUNICATION OF DEVICES
# ON THE NETWORK.

# PYTHON'S STRUCT LIBRARY IS USED TO TRANSFORM DATA AND INFORMATION INTO BYTE PACKAGES, THE CORRECT FORMAT TO BE SENT IN PACKAGES ON T>

# INFORMATIONS OF THE PACKETS, DATA TO PASS:
# \x IS USED FOR REPRESENT A VALUE HEXDECIMAL IN A STRING AND 0x IS USED FOR REPRESENT A VALUE HEXDECIMAL PURE

# CALCULATION RATE TRANSMITION DATA:
# EXEMPLE: 0x82 == 00001100/12dec DO OPERATION and BIT BY BIT WITH 0x7F == 01111111/127dec
# OPERATION: 10000010 AND 01111111 like this remaining: 00000010 == 2, AND THEN: 2 * 500 Kbps = 1 Mb/1000 Kbps   
# HEXADECIMAL IS A TYPE DATA THAT THE PACKETS OF THE NETWORK ACCEPT
# RATE TRANSMITION DATA:  0x82: 1mbps, 0x84: 2mbps, ox8b: 5.5mbps, 0x96: 11mbps, 0x24: 18mbps, 0x30: 24mbps, 0x48: 36mbps, 0x6c: 54mbps

# FORMATTING HEXADECIMAL DATA IN LIST: supported_rates, FOR HEXADECIMAL BYTES, FORMAT NECESSARY TO STRUCTURE PACKAGES WITH struct.pack()

# SENT SIGNAL FOR ALL THE ROUTERS UNDERSTAND THAT YOU WANT TO FIND THEM AND TO CONNECT
# RADIOTAP IS THE STRUCTURE OF HEADERS FROM PACKETS, USEDS FOR GIVING INFORMATIONS IMPORTANTS ABOUT PACKETS, AS FREQUENCY,
    # DBM OF ANTENNA, CHANNEL ON WHICH IT WAS TRANSMITTED, FORCE OF THE SIGNAL, ETC...
    # WITH THE LIBRARY struct WE CAN CREATE PACKETS WITH DATA BYTES FOR BE SENT IN NETWORK.
    # AND THEN WE WILL WAIT FOR PACKETS OF RESPONSE, RECEIVED AND WITH THE struct UNPACK AND TRANSLATE THE DATA.

    # FORMING PACKET:
    # HEADER:
    # LITTLE/BIG ENDIAN ORDER: hexadecimal exemple: 1023/0x3ff. BIG ENDIAN(> 03 ff), LITTLE ENDIAN(< ff 03)
# HEADER MAC(CONTROL ACCESS MIDDLE) OWN ADDRESSES AND OTHER INFORMAÇÕES IMPORTANTS
# RATES SUPPORTEDS:
# PACKET BEACON

import socket
import struct
import psutil
import asyncio
import pyshark

class colors:
      red = "\033[31m"
      green = "\033[32m"
      blue = "\033[34m"
      cyan = "\033[36m"
      purple = "\033[35m"
      reset = "\033[0m"
      pink = "\033[95m"

      # FORMAT TEXT
      bright = '\033[1m'
      background_green = '\033[32m'
      background_red = '\033[41m'
      blink = '\033[5m'
      sublime = '\033[4m'

      # COLOR + BRIGHT
      sb = f'{bright}{sublime}'
      gb = f'{bright}{green}'
      bb = f'{bright}{blue}'

def show_interfaces_addrs():
    try:
       print()
       address_interfaces = psutil.net_if_addrs()
       for interfaces in address_interfaces:
           for info in address_interfaces.get(interfaces):
               if psutil.AF_LINK in info:
                  print(f"{colors.green}{info.address} => {colors.gb}{interfaces}{colors.reset}")
    except Exception as error:
           print(f"Error to get interfaces and address );\n{colors.red}{str(error)}{colors.reset}")

def return_addresses(interface_network):
    addresses_interface = psutil.net_if_addrs()
    if interface_network in addresses_interface:
       for info in addresses_interface.get(interface_network):
           for address in info:
               if psutil.AF_LINK in info:
                  return info.address
    return None

def mac_for_bytes(mac):
    return bytes(int(byte, 16) for byte in mac.split(':'))

def bytes_for_mac(mac):
    return ':'.join(format(byte, '02X') for byte in mac)

def calc_rates(rates):
    list_rates_transmition = []
    for rate in rates:
        # OPERATION: AND BIT BY BIT, (rate binary & value hexadecimal: 0x7f/01111111) * 500 
        value_rate = (rate & 0x7f) * 500
        list_rates_transmition.append(f"{value_rate} Mbps")
    return list_rates_transmition

interface = input("Type it interface Network: ")

# AGROUP ALL PACKETS INFO IN A CLASS packets_info

radiotap_header = struct.pack('<BBH', 0x00, 0x00, 0x0c)

mac_interface = return_addresses(interface)
mac_byte = mac_for_bytes(mac_interface)
destiny_packet = b"\xff\xff\xff\xff\xff\xff"
bssid = b"\xff\xff\xff\xff\xff\xff"
header_radio = struct.pack('<H6s6s6s', 0x0004, destiny_packet, mac_byte, bssid)

supported_rates = [0x82, 0x84, 0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c]
list_rates_transmission = calc_rates(supported_rates)
bytes_rates = bytes(supported_rates)
rates_elements = struct.pack('<BB', 0x01, 0x08) + bytes_rates

ssid = b''
probe_field = struct.pack('<BB', 0x00, 0x00) + ssid

#async def filter_capture_packets(packet, interface_network):
 #         with socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003)) as sock:
  #             sock.bind((interface_network, 0))

# USING STRUCT FOR UNPACK PACKETS AND YOUR DATA, IN CORRECT FORMAT!
# IT IS NECESSARY TO KNOW WHAT TYPES OF DATA ARE COMING, THEIR ORDER AND POSITION, THEREFORE WE NEED COMMUNICATIONS PROTOCOLS WITH 
# STANDARDS FOR SENDING THE DATA IN ORDER, SO THAT OTHER LOW LEVEL PORGRAMS LIKE THIS ARE ABLE TO PREDICT AND PROPERLY DEAL WITH THE 
# DATA EXPECTED
def decode_packets(packet):
    # IDENTIFY PACKET TYPE:
    # HEADER ADDRESS(MAC)
    dst_addr, src_addr, proto = struct.unpack('!6s6sH', packet[18]) 
    dst_addr = bytes_for_mac(dst_addr)
    src_addr = bytes_for_mac(src_addr)
    proto = socket.htons(proto)

    return dst_addr, src_addr, proto

    # HEADER ACCORDINGLY WITH TYPE PACKET
    # TYPES PACKET: 0X00/00000000 Association Request, 0x01/00000001 Association Reponse, 0x04/00000100 Probe Request, 0x05/00001001 Probe Response,
    # 0x0a/00001010 Disassociation, 0x0b/00001011 Authentication, 0x0c/00001100 Deauthentication
    
def send_packets_beacon(interface_network):
    packet_beacon = radiotap_header + header_radio + probe_field + rates_elements
    try:
       print(f"\n{colors.bright}INTERFACE IN OPERATION:{colors.reset} {colors.gb}{interface_network} => {mac_interface} OR {mac_byte}{colors.reset}")
       print(f"\n{colors.bright}SUPPORTED RATES(DEFAULT): {list_rates_transmission} OR {bytes_rates}{colors.reset}")
       print(f"\n{colors.gb}PACKAGE SENT =>{colors.reset} {colors.red}{packet_beacon}{colors.reset}")

       sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
       sock.bind((interface_network, 0))
       sock.send(packet_beacon)
       packet_recv = sock.recv(1024)
       print(packet_recv)
       sock.close()
    except Exception as error:
           print(f"A Error occur ); {colors.red}{str(error)}{colors.reset}")

show_interfaces_addrs()

if mac_interface != None:
   send_packets_beacon(interface)
